#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>
#include <math.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>

struct ThreadArgs {

    int *v;
    int start;
    int end;
    int min;
    int max;

    int *sv;
    int count;

};

int vector_get_in_range_with_threads (int v[], int v_sz, int sv[], int min, int max, int n_threads);

/**
 * Generates a random number between min and max.
 * The number sequence generated by the fuction rand is always the 
 * same because it uses the defaulta seed 0.
 */
int get_random (int min, int max) 
{
    return rand() % (max - min + 1) + min;
}

/**
 * Starts the vector with random values belonging to the interval [min..max]
 */
void vector_init_rand (int v[], long dim, int min, int max)
{
    for (long i = 0; i < dim; i++) {
        v[i] = get_random(min, max);
    }
}

#define LOWER_LIMIT       0
#define UPPER_LIMIT     100
#define BUFFER_SIZE     128000

int main(int argc, char *argv[]){

    if (argc != 3){
        printf("ERRO! ./vector_stat_proc <vector dimension> <number processes>");
        return -1;
    }

    int v_sz = atoi(argv[1]);
    int n_threads = atoi(argv[2]);

    int *values = malloc(sizeof(int) * v_sz);

    if (values == NULL) {
        fprintf(stderr, "Erro malloc\n");
        return -1;
    }

    int *subvalues = malloc(sizeof(int) * v_sz);

    if (subvalues == NULL) {
        fprintf(stderr, "Erro malloc\n");
        return -1;
    }

    vector_init_rand(values, v_sz, LOWER_LIMIT, UPPER_LIMIT);

    struct timeval t1,t2;
    gettimeofday(&t1, NULL);

    int count = vector_get_in_range_with_threads(values, v_sz, subvalues, 50, 100, n_threads);

    gettimeofday(&t2, NULL);
    long elapsed = ((long)t2.tv_sec - t1.tv_sec) * 1000000L + (t2.tv_usec - t1.tv_usec);
    long sec = elapsed / (long)1e6;
    long aux = elapsed % (long)1e6;
    long mil = aux / (long)1e3;
    long mic = aux % (long)1e3;

    printf("Elapsed time = %lds%ld,%ldms\n", sec, mil, mic);
    printf("O subvalues tem %d elementos\n", count);

    free(values);
    free(subvalues);
    
    return 0;
}

void * get_vector_in_range(void * _arg){

    struct ThreadArgs *arg = (struct ThreadArgs *) _arg;
    int count = 0;

    for (int i = arg->start; i < arg->end; i++){
        
        int e = arg->v[i];

        if (e <= arg->max && e >= arg->min){
            arg->sv[count] = e;
            count++;
        }

    }

    arg->count = count;

    return NULL;
}

int vector_get_in_range_with_threads (int v[], int v_sz, int sv[], int min, int max, int n_threads){

    int count = 0;
    int k = 0;
    int size = v_sz / n_threads;
    pthread_t thid[n_threads];
    struct ThreadArgs args[n_threads];
    
    for (int i = 0; i < n_threads; i++){

        args[i].v = v;
        args[i].start = i * size;
        args[i].end = args[i].start + size;
        args[i].min = min;
        args[i].max = max;
        int *ar = malloc(sizeof(int) * size);
        args[i].sv = ar;

        int error;

        if ((error = pthread_create(&thid[i], NULL, get_vector_in_range, &args[i])) != 0){
            errno = error;
            perror("Erro ao criar a thread\n");
            exit(-1);
        }

    }

    for (int i = 0; i < n_threads; i++){

        int error;

        if ((error = pthread_join(thid[i], NULL)) != 0){
            errno = error;
            perror("Erro ao esperar pela thread\n");
            exit(-1);
        }

        struct ThreadArgs arg = args[i];
        count += arg.count;

        for (int j = 0; j < arg.count; j++){
            sv[k++] = arg.sv[j];
        }

        free(arg.sv);
    }
    
    return count;
}